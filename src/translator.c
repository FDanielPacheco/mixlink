/***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
 * Introduction
 **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

/**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************//**
 * @file      translator.c
 * 
 * @version   1.0
 *
 * @date      09-10-2025
 *
 * @brief     Functions related to the translator block.
 *  
 * @author    Fábio D. Pacheco, 
 * @email     fabio.d.pacheco@inesctec.pt or pacheco.castro.fabio@gmail.com
 *
 * @copyright Copyright (c) [2025] [Fábio D. Pacheco]
 * 
 * @note      Manuals:
 * 
 **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

/***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
 * Imported libraries
 **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <errno.h> 
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ether.h>
#include <linux/if_packet.h> 
#include <net/if.h>

#include "translator.h"

/***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
 * Local Prototypes
 **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

int rawsocket( 
  const char * interface
);

int8_t try_init_nic(
  struct nic_handler * nic,
  mixlink_param_dev_t  param
);

int8_t translator_valid( 
  mixlink_translator_t * translator           
);

int8_t translator_io_cb(
  uint8_t * data, 
  ssize_t * len,
  const ssize_t size,
  const enum direction dir, 
  const mixlink_module_t * mod
);

/***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
 * Function Description
 **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
int
rawsocket( 
  const char * interface
){

  if( !interface ){
    errno = EINVAL;
    return -1;
  }

  struct sockaddr_ll socaddr;

  int rs = socket( 
    AF_PACKET, 
    SOCK_RAW, 
    htons(ETH_P_ALL)
  );
  if( 0 > rs )
    return -1;

  int ifindex = (int) if_nametoindex( interface );
  if( !ifindex ){
    close( rs );
    return -1;
  }

  memset( &socaddr, 0, sizeof(socaddr) );
  socaddr.sll_family = AF_PACKET;
  socaddr.sll_protocol = htons(ETH_P_ALL);
  socaddr.sll_ifindex = ifindex;

  int bd = bind( 
    rs, 
    (struct sockaddr *) &socaddr, 
    sizeof(socaddr)
  );
  if( 0 > bd ){
    close( rs );
    return -1;
  }

  return rs;
}

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/ 
int8_t 
try_init_nic(
  struct nic_handler * nic,
  mixlink_param_dev_t  param
){
  
  if( !nic ){
    errno = EINVAL;
    return -1;
  }

  int soc = rawsocket( param.name );
  if( -1 != soc ){
    nic->soc = soc;
    nic->enabled = true;
    (void) strncpy( nic->name, param.name, NAME_MAX );
    nic->name[ NAME_MAX - 1 ] = '\0'; 
    return 0;
  }
  
  return -1;
}

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/ 
int8_t 
translator_valid( 
  mixlink_translator_t * translator           
){

  if( !translator ){
    errno = EINVAL;
    return -1;
  }
  return 0;
}


/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/ 
int8_t 
mixlink_translator_init( 
  const mixlink_param_translator_t param,
  mixlink_translator_t * translator           
){

  if( -1 == translator_valid( translator ) )  
    return -1;
  
  (void) memset( translator, 0, sizeof(mixlink_translator_t) );

  bool failed2soc = true;
  
  int ret = try_init_nic( 
    &translator->def,
    param.nic.def
  );

  if( -1 == ret ){
    if( !try_init_nic( &translator->pair.rx, param.nic.pair.rx ) )
      failed2soc = false;
    if( !try_init_nic( &translator->pair.tx, param.nic.pair.tx ) )
      failed2soc = false;
  }
  else
    failed2soc = false;

  if( failed2soc )
    return -1;

  (void) mixlink_mod_load( 
    param.opt, 
    MIXLINK_STACK_SECTION_TRANSLATOR_OPT,
    &translator->opt
  );

  (void) mixlink_mod_load(
    param.framer, 
    MIXLINK_STACK_SECTION_TRANSLATOR_FRAMER,
    &translator->framer
  );

  return 0;
}

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/ 
int8_t 
mixlink_translator_close(
  mixlink_translator_t * translator
){
  
  if( -1 == translator_valid( translator ) )  
    return -1;

  const int8_t n_nics = 3;
  struct nic_handler * nics[ n_nics ] = {
    &translator->def,
    &translator->pair.tx,
    &translator->pair.rx
  };

  for( int8_t i = 0; i < n_nics ; ++i ){
    if( nics[i]->enabled && 0 <= nics[i]->soc ){
      (void) close( nics[i]->soc );
      nics[i]->enabled = false;
      nics[i]->soc = -1;
    }
  }

  (void) mixlink_mod_unload( &translator->opt );
  (void) mixlink_mod_unload( &translator->framer );

  return 0;
}

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/ 
ssize_t 
mixlink_translator_write(
  const mixlink_translator_t * translator,
  const uint8_t * data, 
  const ssize_t len
){

  if( -1 == translator_valid( translator ) )  
    return 0;

  int soc = -1;
  if( translator->def.enabled )
    soc = translator->def.soc;
  else if( translator->pair.rx.enabled )
    soc = translator->pair.rx.soc;
  else 
    return 0;

  return write( 
    soc,
    data,
    len
  );
}

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/ 
ssize_t 
mixlink_translator_read( 
  uint8_t * buf,
  const ssize_t size,
  const ssize_t offset,
  const ssize_t len,
  const mixlink_translator_t * translator
){

  if( -1 == translator_valid( translator ) )  
    return 0;

  if( !buf || !len || !size ){
    errno = EINVAL;
    return 0;
  }  

  if( size < (offset + len) ){
    errno = ENOMEM;
    return 0;
  }  

  int soc = -1;
  if( translator->def.enabled )
    soc = translator->def.soc;
  else if( translator->pair.tx.enabled )
    soc = translator->pair.tx.soc;
  else 
    return 0;

  return read( 
    soc, 
    &buf[offset], 
    len
  ); 
}

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/ 
int8_t 
translator_io_cb(
  uint8_t * data, 
  ssize_t * len,
  const ssize_t size,
  const enum direction dir, 
  const mixlink_module_t * mod
){
  if( !data || !len || !size || !mod ){
    errno = EINVAL;
    return 0;
  }      

  mixlink_translator_cb_t arg = {
    .data = data,
    .len = len,
    .size = size
  };

  if( MIXLINK_DIRECTION_TO_NIC == dir )
    if( mod->rx.enabled )
      return mod->rx.fn( (void *) &arg );
  
  if( MIXLINK_DIRECTION_FROM_NIC == dir )
    if( mod->tx.enabled )
      return mod->tx.fn( (void *) &arg );

  return 0;  
}


/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/ 
int8_t 
mixlink_translator_optimizer_io(
  uint8_t * data, 
  ssize_t * len,
  const ssize_t size,
  const enum direction dir, 
  const mixlink_translator_t * translator
){
  
  if( -1 == translator_valid( translator ) )  
    return 0;
      
  return translator_io_cb(
    data, len, size, dir,
    &translator->opt
  );
}

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/ 
int8_t 
mixlink_translator_framer_io(
  uint8_t * data, 
  ssize_t * len,
  const ssize_t size,
  const enum direction dir, 
  const mixlink_translator_t * translator
){
  
  if( -1 == translator_valid( translator ) )  
    return 0;
      
  return translator_io_cb(
    data, len, size, dir,
    &translator->framer
  );
}